# 进程环境

## 1.进程的启动与终止

<div align="center"> <img src="pic/apue-processenv-3.png"/> </div>

### 1.1 main函数

当内核通过`exec`函数执行 C 程序、在调用`main`之前先调用一个特殊的启动例程

* 可执行程序文件将此启动例程指定为程序的起始地址（这是由链接器设置的，而链接器由C编译器调用）
* 启动例程从内核取得命令行参数和环境变量值，为调用`main`函数做好安排

启动例程使得从main返回后立即调用exit函数。

```c
exit(main(argc,argv));
```

### 1.2 进程终止的方式

有 8 种方式使得进程终止，其中 5 种为正常终止，3 种异常终止：


- **正常终止方式**：
    - 从`main`函数返回
    - 调用`exit`函数
    - 调用`_exit`函数或者`_Exit`函数
    - 多线程的程序中，最后一个线程从其启动例程返回
    - 多线程的程序中，从最后一个线程调用`pthread_exit`函数
- **异常终止方式**：
    - 调用`abort`函数
    - 接收到一个信号
    - 多线程的程序中，最后一个线程对取消请求作出响应

### 1.3 终止函数

三个终止函数的区别：
- `_exit`和`_Exit`函数：立即进入内核
- `exit`函数：先执行一些清理处理，然后进入内核

### 1.4 终止状态

`exit`、`exit`、`_Exit` 都带有一个整型参数，称为终止状态（或称作退出状态）。


* 下列情况，进程的**终止状态是未定义**的：
    + 若调用`exit`、`exit`、`_Exit`时不带终止状态
    + 若`main`执行了一个无返回值的`return`语句
    + 若`main`没有声明返回类型为整型
* 下列情况，进程的**终止状态是0**： 
    + 若`main`声明返回类型为整型，并且`main`执行到最后一条语句时返回（隐式返回）


### 1.5 登记终止处理程序
```
#include <stdlib.h>
int atexit(void (*function)(void));
```
按照ISO C的规定，一个进程可以登记最多32个函数（通常操作系统会提供多于32个的限制。可以用`sysconf`函数查询这个限制值），这些函数将由`exit`函数自动调用。这些函数称作**终止处理程序**

* `exit`调用这些终止处理程序的顺序与它们登记的时候顺序相反
* 如果同一个终止处理程序被登记多次，则它也会被调用多次


## 2.环境表

每个程序都会接收一张**环境表**
- 与参数表一样，环境表也是一个字符指针数组
    - 其中数组中的每个指针指向一个以`null`结束的 C 字符串，这些字符串称之为环境字符串
    - 数组的最后一项是`null`
- 全局变量`environ`包含了该指针数组的地址：`extern char **environ`。我们称`environ`为环境指针，它位于头文件`unistd.h`中
- 按照惯例，环境字符串由`name=value`这种格式的字符串组成

<div align="center"> <img src="pic/apue-processenv-4.png"/> </div>

> 环境表和环境字符串通常存放在进程存储空间的顶部（栈的上方）


## 3.C程序的存储空间布局

<div align="center"> <img src="pic/apue-processenv-5.png"/> </div>

* **正文段**（.text段）：这是由CPU执行的机器指令部分
    * 通常正文段是可以共享的。一个程序可以同时执行`N`次，但是该程序的正文段在内存中只需要有一份而不是`N`份
    * 通常正文段是只读的，以防止程序由于意外而修改其指令
* **初始化数据段**（.data段）：通常将它称作数据段（存放在磁盘可执行文件中，故而占磁盘空间）
    * 它包含了程序中明确地赋了初值的变量：包括**函数外的赋初值的全局变量**、**函数内的赋初值的静态变量**
* **未初始化数据段**（.bss段）：通常将它称作**bss段**。在程序开始执行之前，内核将此段中的数据初始化为0或者空指针
    * 它包含了程序中未赋初值的变量：包括**函数外的未赋初值的全局变量**、**函数内的未赋初值的静态变量**
* **栈**：临时变量以及每次函数调用时所需要保存的信息都存放在此段中
    * 每次函数调用时，函数返回地址以及调用者的环境信息（如某些CPU 寄存器的值）都存放在栈中
    * 最新的正被执行的函数，在栈上为其临时变量分配存储空间（通过这种方式使用栈，C 递归函数可以工作。递归函数每次调用自身时，就创建一个新的栈帧，因此某一次函数调用中的变量不影响下一次调用中的变量）
* **堆**：通常在堆中进行动态存储分配
    

## 4.共享库

### 静态链接库与动态链接库

* **静态链接库**
    - 扩展名为`.a`，通常命名为`libxxx.a`
    - 整合到可执行文件中，因此会导致可执行文件体积增大
    - 可独立执行，而不需要再向外部要求读取链接库的内容
    - 链接库升级时，需要重新编译生成可执行文件

* **动态链接库**
    - 扩展名为`.so`，通常命名为`libxxx.so`
    - 动态链接库的内容并没有整合到可执行文件中，需要使用时才去读取链接库，因此可执行文件体积较小
    - 不能独立执行，链接库必须存在
    - 链接库升级时，通常不需要重新编译

为了加速动态链接库的访问效率，一般需要将动态链接库载入内存中，从而避免读取磁盘。加载到高速缓存中的动态链接库所在的目录在文件`/etc/ld.so.conf`中指定，可以使用命令`ldconfig`将该文件中指定目录下的动态库读入缓存中

如果在编译时指定了动态链接库及库的路径，但是`/etc/ld.so.conf`文件中没有包含该路径，即这个动态链接库没有载入内存，那么运行生成的可执行文件会报错

`ldd`命令可以查看某个可执行的二进制文件含有什么动态链接库，对于前面的问题，如果某个动态链接库没有载入内存，即动态链接库的路径没有包含在文件`/etc/ld.so.conf`中。使用ldd查看时，这个库会显示“not found”

## 5.进程堆空间的管理
> 堆上空间分配和释放核心都是通过调整**program break**来实现的，malloc和free维护空闲空间链表，以减少调整**program break**的系统调用的调用次数

### 1）调整program break来分配与释放
可以通过**brk**函数和**sbrk**函数改变进程的**program break**位置，从而分配或释放内存。

**program break的位置抬升后，程序可以访问新分配区域内的任何内存地址，而此时物理内存页尚未分配。内核会在进程首次试图访问这些虚拟内存地址时自动分配新的物理内存页**


### 2）使用C库函数进行分配释放
malloc相比brk和sbrk，具有以下优点：

* 属于C标准的一部分
* 更易于在多线程程序中使用
* 接口简单，允许分配小块内存
* 允许随意释放内存块，它们被维护于一张空闲内存列表内，在后续分配内存时循环使用


malloc calloc  realloc

* `malloc` ：分配指定字节数的存储区。存储区中的初始值不确定
    - malloc返回内存所采用的字节对齐方式，总是适宜于高效访问任何类型的C语言数据结构。在大多数架构上，意味着malloc是基于8字节或16字节边界来分配内存的
    - malloc(0)要么返回NULL，要么是一块可（并且应该）被free释放的内存
* `calloc` ：为指定数量指定长度的对象分配存储空间。空间中的每一位都初始化为0
* `realloc` ：增加或减少以前分配区的长度
    - 当增加长度时，可能需将以前分配区的内容移到另外一个足够大的区域，以便在尾端提供增加的存储区，而新增区域内的初始值则不确定
    - 函数调用前后可能是不同的存储区，所以调用前不应该有指针指向这段存储区，不然修改后，可能该指针会非法访问
    - 应该使用另一个指针保存`realloc`的返回值，因为如果使用传入的实参保存返回值，那么一旦`realloc`失败，则会传回NULL，原来的动态内存区再也无法访问，从而发生内存泄露
    
free
* `free` ：上述3个函数都需通过free释放。一般情况下，free并不降低**program break**的位置，而是将这块内存增加到空闲内存列表中，供后续的malloc循环使用，原因是：
    - 被释放的内存块通常会位于堆的中间，而非堆的顶部，因为降低**program break**是不可能的
    - 它最大限度地减少了程序必须执行的`sbrk`调用次数
    - 在大多数情况下，降低**program break**不会对那些分配大量内存的程序有多少帮助，因为它们通常倾向于持有已分配内存或是反复释放和重新分配内存，而非释放所有内存后再持续运行一段时间

**这些分配例程通常用`sbrk`系统调用实现**

* `sbrk`可以扩充或缩小进程的存储空间。但是大多数malloc和free的实现都不减小进程的存储空间：释放的空间可供以后再分配，将它们保持在malloc池中而不返回给内核
* 大多数实现所分配的存储空间要比所要求的稍大一些，额外的空间用来记录管理信息，比如分配块的长度、指向下一个分配块的指针等等

**malloc的实现**


1. 首先会扫描之前由free释放的空闲内存块列表，试图找到尺寸大小**大于或等于**要求的一块空闲内存
    * 如果一内存块的尺寸恰好符合要求，那么直接返回给调用者
    * 如果内存块较大，那么进行分割，将一块大小相当的内存返回给调用者，剩余内存块保留在空闲列表
2. 如果空闲内存列表中根本找不到足够大的空闲内存块（**如首次调用malloc时**），那么malloc会调用**sbrk**以分配更多的内存（为了减少对**sbrk**的调用次数，malloc并不是严格按所需字节数来分配内存，而是以更大幅度来增加**program break**，并将超出部分置于空闲内存列表）

当malloc分配内存块时，会额外分配几个字节来存放**记录这块内存大小的整数值**。该整数位于内存块的起始处，而实际返回给调用者的内存地址恰好位于 这一长度记录字节之后：

<div align="center"> <img src="pic/apue-processenv-15.png"/> </div>

**free的实现**

1. free会使用内存块本身的空间来存放链表指针，将自身添加到列表中

<div align="center"> <img src="pic/apue-processenv-16.png"/> </div>

2. 随着对内存不断地释放和重新分配，空闲列表中的空闲内存会和已分配的在用内存混杂在一起

<div align="center"> <img src="pic/apue-processenv-17.png"/> </div>

> C语言允许程序创建指向堆中任意位置的指针，并修改其指向的数据，包括由free和malloc函数维护的内存长度、指向前一空闲块和后一空闲块的指针。如果发生这种缓冲区溢出的情况，会带来严重的后果



# 五.进程控制

## 1.进程标识
进程通过进程ID进行标识

### 1.1 两个特殊进程

* **0号进程：调度进程(也被称为系统进程或交换进程)**
    - **性质**：内核的一部分，并不执行任何磁盘上的程序
* **1号进程：init进程**
    - **性质**：普通进程，但以超级用户特权运行。
    - **启动时机**：在自举过程结束时由内核调用
    - **职责**：
        + 读取与系统有关的初始化文件，并将系统引导到一个状态（如多用户）
        + 成为所有孤儿进程的父进程

## 2.进程的创建

```
pid_t fork(void)
pid_t vfork(void)
```
### 2.1 fork

<div align="center"> <img src="pic/fork.png"/> </div>


#### 1）执行顺序

一般来说，fork后父子进程谁先执行是不确定的，取决于内核所用的调度算法

#### 2）数据共享


因为fork之后经常跟随着`exec`，所以很多实现中，子进程的**数据段**、**堆**和**栈**指向相应的父进程版本，因此父子进程共享使用，如果子进程有修改，会执行**写时复制**(**COW**)（通常将修改所在的一”页“进行复制）。从而不会影响父进程


* 注意父子进程之间**I/O缓冲区**的复制：
    + 文件I/O中write不带缓冲
    + 标准I/O库带缓冲。因此要特别注意父子进程间缓冲区的复制
* 注意父子进程的**文件描述符**：
    - **在重定向父进程的标准输出时，子进程的标准输出也会被重定向**
    + `fork`的一个特性是父进程的所有打开文件描述符都被”复制“到子进程中，**父子进程每个相同的打开描述符共享一个文件表项**（故**父子进程共享同一个文件偏移量**
    ）

 <div align="center"> <img src="pic/apue-processctr-3.png"/> </div>

 **父子进程的区别**为：
 
- `fork`返回值不同
- 进程`ID`不同
- 进程父进程`ID`不同
- 子进程的`tms_utime,tms_stime,tms_cutime,tms_ustime`的值设置为0
- 子进程不继承父进程设置的文件锁
- 子进程的未处理闹钟被清除
- 子进程的未处理信号集设置为空集


### 2.2 vfork
fork用于创建一个新进程，该新进程的目的是exec一个新程序，因此子进程并不将父进程的地址空间完全复制到子进程中

在子进程调用exec或exit之前，它在父进程的空间中运行。但如果子进程修改数据、进程函数调用、或者没有调用exec或exit就返回都可能会带来未知的结果

`vfork`和`fork`之间的另一个区别是：**`vfork`保证子进程先运行**，在它调用exec或exit之后父进程才可能被调度运行（如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁）

## 3.进程的终止

有 8 种方式使得进程终止，其中 5 种为正常终止，3 种异常终止：

- **正常终止方式**：
    - 从`main`函数返回
    - 调用`exit`函数
    - 调用`_exit`函数或者`_Exit`函数
    - 多线程的程序中，最后一个线程从其启动例程返回
    - 多线程的程序中，从最后一个线程调用`pthread_exit`函数
- **异常终止方式**：
    - 调用`abort`函数
    - 接收到一个信号
    - 多线程的程序中，最后一个线程对取消请求作出响应


### 3.1 子进程向父进程传递状态


* **子进程正常终止**：子进程将其退出状态作为参数传给`exit`、`_exit`、`_Exit`
* **子进程异常终止**：内核会产生一个指示子进程异常终止原因的终止状态

不管正常终止或异常终止，内核都向父进程发送`SIGCHLD`信号，父进程可以选择忽略该信号(**默认动作**)，或者提供一个信号处理函数

父进程能通过`wait`、`waitpid`获取子进程的终止状态


### 3.2 父子进程以不同顺序终止

* **父进程在子进程之前终止**：该进程的所有子进程会变成**孤儿进程**，这些孤儿进程会被init进程收养，作为新的父进程
* **子进程在父进程之前终止**：无法确保子进程终止时，父进程已经准备好了检查其终止状态。因此内核为每个终止子进程保存了一定量的信息。当父进程调用`wait`或`waitpid`时，可以得到这些信息。这些信息至少包括进程ID、进程的终止状态、进程使用的CPU时间总量。在父进程调用`wait`或`waitpid`之前，终止子进程被称为**僵死进程**（init的子进程终止时，init就会调用一个`wait`函数取得其终止状态）

## 4.竞争条件

**竞争条件是多个进程企图对共享数据进程某种处理，最终结果取决于进程运行的顺序**

好的办法是使用信号进行通信，或者使用IPC

## 5.exec函数

当进程调用一种`exec`函数时，该进程执行的程序完全替换成新程序，而新程序则从`main`函数开始执行

- 调用`exec`前后，进程`ID`并未改变。因为`exec`并不创建新进程
- `exec`只是用磁盘上的一个新程序替换了当前进程的**正文段**、**数据段**、**堆**和**栈**

有7种不同的`exec`函数可以供使用，它们被统称称作`exec`函数：

7个函数之间的关系如下图：
<div align="center"> <img src="pic/apue-processctr-9.png"/> </div>

## 6.system函数

system` VS `fork + exec`：

* **优点**：`system`进行了所需的各种出错处理以及各种信号处理
* **缺点**：一旦调用`system`的进程具有超级用户权限，则`system`执行的命令也具有超级用户权限。因为`system`的实现过程中并没有更改`有效用户ID`和`实际用户ID`的操作
    - 因此如果一个进程以特殊的权限运行，而它又想生成另一个进程执行另外一个程序，则它应该直接使用`fork + exec`并且在`fork`之后，`exec`之前改回普通权限
    - 设置用户`ID`和设置组`ID`程序绝不应该调用`system`函数