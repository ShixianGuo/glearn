
## 1.I/O缓冲

**缓冲技术**：在输入请求发出之前就开始执行输入传送，并且在输出请求发出一段时间之后才开始执行输出传送，这项技术称为缓冲

两类I/O设备：

* **面向块的I/O设备**：将信息保存在块中，块的大小通常是固定的，传送过程中一次传送一块
* **面向流的I/O设备**：以字节流的方式输入/输出数据，没有块结构


### 1.1 单缓冲

![](pic/os-9-1.png)

**对于面向块的I/O设备**：

* 输入传送的数据被放到系统缓冲区中。当传送完成时，进程把该块移到用户空间，并立即请求另一块
* 相对于无缓冲的情况，这种方法通常会提高系统速度。用户进程可以在下一数据块读取的同时，处理已读入的数据块。由于输入发生在系统内存中而非用户进程内存中，因此操作系统可以将该进程换出

**对于面向流的I/O设备**：

单缓冲方案能以每次传送一行的方式或者每次传送一个字节的方式使用


### 1.2 双缓冲(缓冲交换)

![](pic/os-9-2.png)

分配2个缓冲区。在一个进程往一个缓冲区中传送数据(从这个缓冲区中取数据)的同时，操作系统正在清空(或者填充)另一个缓冲区

### 1.3 循环缓冲

![](pic/os-9-3.png)

双缓冲方案可以平滑I/O设备和进程之间的数据流。如果关注的焦点是某个特定进程的性能，那么常常会希望相关I/O操作能够跟得上这个进程。如果该进程需要爆发式地执行大量的I/O操作，仅有双缓冲就不够了，在这种情况下，通常使用多于两个的缓冲区方案来缓解不足


### 1.4 I/O缓冲的作用

I/O缓冲是用来平滑I/O需求的峰值的一种技术，但是当进程的平均需求大于I/O设备的服务能力时，缓冲再多也不能让I/O设备与这个进程一直并驾齐驱。即使有多个缓冲区，所有的缓冲区终将会被填满，进程在处理完每一大块数据后不得不等待。但是，在多道程序设计环境中，当存在多种I/O活动和多种进程活动时，缓冲是提高操作系统效率和单个进程性能的一种方法

## 2.磁盘调度

### 2.1 磁盘性能参数

* **寻道时间**：磁头定位到磁道所需的时间
* **旋转延迟**：选好磁道后，磁头到达扇区开始位置的时间
* **存取时间**：寻道时间+旋转延迟
* **传输时间**：磁头定位到扇区开始位置后，数据读写的时间
* **排队时间**

### 2.2 磁盘调度算法

在多道程序环境中，操作系统为每个I/O设备维护一个请求队列。因此对一个磁盘，队列中可能有来自多个进程的许多I/O请求。如果随机地从队列中选择请求，那么磁道完全是被随机访问的，这种情况下性能最差。**随机调度**可用于与其他调度算法进行对比

**1）先进先出(FIFO)**

* 按顺序处理队列中的请求
* 如果有大量进程竞争一个磁盘，这种算法在性能上往往接近于随机调度

**2）优先级**

* 这种方法不会优化磁盘利用率，但可以满足操作系统的其它目标
* 通常比较短的批作业和交互作业的优先级比较高。长作业可能饥饿
* 可能会导致部分用户采用对抗手段：把作业分成小块，以回应系统的这种策略。对于数据库系统，这种算法往往性能较差

**3）最短服务时间优先(SSTF)**

* 选择使磁头臂从当前位置开始移动最少(最小寻道时间)的磁盘I/O请求
* 但是，总是选择最小寻道时间并不能保证平均寻道时间最小，不过能提供比FIFO更好的性能
* 磁头臂可以沿两个方向移动

**3）SCAN**

* 运行类似电梯。磁头臂沿某一方向移动，并在途中满足所有未完成请求，直到到达最后一个磁道，或者该方向上没有更多请求。接着反转服务方向
* 偏向接近最靠里或最靠外的磁道的请求，并且偏向最近的请求，可能发生饥饿

**4）C-SCAN**

* 沿某个方向的扫描结束后，返回到相反方向的末端，再次扫描
* 减少了新请求的最大延迟
* 可能饥饿

**5）N-step-SCAN(N步扫描)**

SSTF、SCAN和C-SCAN可能在一段很长时间内磁头臂都不会移动(比如一个或多个进程对一个磁道有较高的访问速度，通过重复的请求这个磁道垄断整个设备)，从而饥饿其它请求

* 把请求队列分成长度为N的子队列，每一次用SCAN处理一个子队列。在处理一个子队列时，新请求必须添加到其它某个队列中
* 对于比较大的N值，性能接近SCAN；当N=1时，实际上就是FIFO


### 2.3 磁盘调度算法比较

假设有一些I/O请求，需问这些磁道：55、58、39、18、90、160、150、38、184

使用不同磁盘调度算法的结果如下：

![](../pic/os-9-4.png)

## 3.磁盘高速缓存

一个磁盘高速缓存是内存中为磁盘扇区设置的一个缓冲区，它包含有磁盘中某些扇区的副本。当出现一个请求某一特定扇区的I/O请求时，首先进行检查，以确定该扇区是否在磁盘高速缓存中。如果在，则该请求可以通过这个高速缓存来满足；如果不在，则把请求的扇区从磁盘读到磁盘高速缓存