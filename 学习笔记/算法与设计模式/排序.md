# 排序 

<div align="center"> <img src="pic/八大排序.png"/> </div>


## 冒泡排序

思想： 大数沉底

```c++
void sort(int[] nums) {
    //定义一个布尔变量 hasChange，用来标记每轮遍历中是否发生了交换
    boolean hasChange = true; 
    //每轮遍历开始，将 hasChange 设置为 false
    for (int i = 0; i < nums.length - 1 && hasChange; i++) {
        hasChange = false;
        //进行两两比较，同时记录一下有交换发生
        for (int j = 0; j < nums.length - 1 - i; j++) {
            if (nums[j] > nums[j + 1]) {
                swap(nums, j, j + 1);
                hasChange = true;
            }      
        }
     }
 }
```



## 快速排序

<div align="center"> <img src="pic/快排01.png"/> </div>
<div align="center"> <img src="pic/快排02.png"/> </div>

```cpp

typedef int Rank;

//轴点构造算法：通过调整元素位置构造区间[lo, hi)的轴点，并返回其秩
Rank  partition(vector<Rank>& elem, Rank lo, Rank hi) { //版本A：基本形式

    swap(elem[lo], elem[lo + rand() % (hi - lo)]); //任选一个元素与首元素交换
    hi--;      //[lo, hi)                                   
    Rank pivot = elem[lo];                         //以首元素为候选轴点——经以上交换，等效于随机选取

    while (lo < hi) { //从向量的两端交替地向中间扫描

        while ((lo < hi) && (pivot <= elem[hi])) //在不小于pivot的前提下
            hi--; //向左拓展右端子向量
        elem[lo] = elem[hi]; //小于pivot者归入左侧子序列

        while ((lo < hi) && (elem[lo] <= pivot)) //在不大于pivot的前提下
            lo++; //向右拓展左端子向量
        elem[hi] = elem[lo]; //大于pivot者归入右侧子序列

    } //assert: lo == hi

    elem[lo] = pivot; //将备份的轴点记录置于前、后子向量之间
    return lo; //返回轴点的秩
}

void quickSort(vector<Rank>& elem, Rank lo, Rank hi) { //0 <= lo < hi <= size

    if (hi - lo < 2) return; //单元素区间自然有序，否则...

    Rank mi = partition(elem, lo, hi); //在[lo, hi)内构造轴点

    quickSort(elem, lo, mi); //对前缀递归排序
    quickSort(elem, mi + 1, hi); //对后缀递归排序
}
```

## 插入排序
<div align="center"> <img src="pic/插入排序.png"/> </div>

```c++
void sort(int[] nums) {
    // 将数组的第一个元素当作已经排好序的，从第二个元素，即 i 从 1 开始遍历数组
    for (int i = 1, j, current; i < nums.length; i++) {
        // 外围循环开始，把当前 i 指向的值用 current 保存
        current = nums[i];

        // 指针 j 内循环，和 current 值比较，若 j 所指向的值比 current 值大，则该数右移一位
        for (j = i - 1; j >= 0 && nums[j] > current; j--) {
            nums[j + 1] = nums[j];
        }
    
        // 内循环结束，j+1 所指向的位置就是 current 值插入的位置
        nums[j + 1] = current;
    }
}
```

## 希尔排序 
<div align="center"> <img src="pic/希尔排序01.png"/> </div>
<div align="center"> <img src="pic/希尔排序03.png"/> </div>
<div align="center"> <img src="pic/希尔排序04.png"/> </div>

```cpp
typedef int Rank;
void shellSort(vector<Rank>& elem,Rank lo, Rank hi) { //0 <= lo < hi <= size <= 2^30
   
    for (int d = 0x3FFFFFFF; 0 < d; d >>= 1) //PS Sequence: { 1, 3, 7, 15, ..., 1073741823 }
        for (int j = lo + d; j < hi; j++) { //for each j in [lo+d, hi)
            Rank x = elem[j]; int i = j - d;
            while (lo <= i && elem[i] > x)
            {
                elem[i + d] = elem[i]; i -= d;
            }
            elem[i + d] = x; //insert [j] into its subsequence
        }
}
```

<div align="center"> <img src="pic/希尔排序05.png"/> </div>

## 选择排序
冒泡排序： 
* 每次排序 都等价于 将最大元素转到 有序序列和无序序列的分界点  从这个角度看 冒泡排序就是选择排序
    1 相邻元素比较   2 元素位置交换  然而很遗憾 将最大元素转到合适位置的任务 是由一系列短距离也就是相邻元素之间的移动构成 
           这种小步慢跑的移动 就是低效率来源  那为啥不一次到位？

选择排序： 每次迭代只做了一次元素的移动  而不是像冒泡排序那样 在每一步都有可能做元素移动 

<div align="center"> <img src="pic/选择排序01.png"/> </div>

```cpp
template <typename T> //列表的选择排序算法：对起始于位置p的n个元素排序
void List<T>::selectionSort(ListNodePosi(T) p, int n) { //valid(p) && rank(p) + n <= size

    ListNodePosi(T) head = p->pred; ListNodePosi(T) tail = p;

    for (int i = 0; i < n; i++) tail = tail->succ; //待排序区间为(head, tail)

    while (1 < n) { //在至少还剩两个节点之前，在待排序区间内
        ListNodePosi(T) max = selectMax(head->succ, n); //找出最大者（歧义时后者优先）
        insertB(tail, remove(max)); //将其移至无序区间末尾（作为有序区间新的首元素）
        tail = tail->pred; n--;
    }
}
```

## 堆排序 

###  完全二叉堆
结构：
<div align="center"> <img src="pic/堆排序01.png"/> </div>
插入与上滤

删除与上滤



## 归并排序

<div align="center"> <img src="pic/归并排序01.png"/> </div>

```cpp
void sort(int*A, int lo, int hi) {
  // 判断是否只剩下最后一个元素
  if (lo >= hi) return;
  
  // 从中间将数组分成两个部分
  int mid = lo + (hi - lo) / 2;
  
  // 分别递归地将左右两半排好序
  sort(A, lo, mid);
  sort(A, mid + 1, hi);

  // 将排好序的左右两半合并  
  merge(A, lo, mid, hi);
}

void merge(int* nums, int lo, int mid, int hi) {
    // 复制一份原来的数组
    int[] copy = nums.clone();
  
    // 定义一个 k 指针表示从什么位置开始修改原来的数组，i 指针表示左半边的起始位置，j 表示右半边的起始位置
    int k = lo, i = lo, j = mid + 1;
  
    while (k <= hi) {
        if (i > mid) {
            nums[k++] = copy[j++];
        } else if (j > hi) {
          nums[k++] = copy[i++];
        } else if (copy[j] < copy[i]) {
          nums[k++] = copy[j++];
        } else {
          nums[k++] = copy[i++];
        }
    }
}
```

## 基数排序





