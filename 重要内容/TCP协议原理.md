# 1 TCP header

<div align="center"> <img src="pic/TCPHeader.png"/> </div>

需要注意的是

* TCP的包是没有IP地址的，那是IP层上的事，但是有源端口和目标端口。  
* `一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。`但因为这里只是说TCP协议，所以，这里我只说四元组。

上图中的四个非常重要的东西：
* Sequence Number：是包的序号，用来解决网络包乱序（reordering）问题。
* Acknowledgement Number：就是ACK——用于确认收到，用来解决不丢包的问题。
* Window：也就是著名的滑动窗口（Sliding Window），用于解决流控的。 这个值本身是通过拥塞控制算出来的
* TCP Flag ：也就是包的类型，主要是用于操控TCP的状态机的。


# 2 TCP stream / tcb  

用来干啥？  
```
用户态应用程序 和TCP的连接桥梁
```

里面主要有啥？
```
1 五元组：源端口号 源IP  目的端口号  目的IP 协议类型
2 status： 十一种状态
3 发送队列
4 接收队列
5 fd
```

应用程序的fd 和 tcb 有啥关系？ 

```
send(fd):  fd  去找 tcb
recv(fd):  tcb 去找 fd
```

# 3 TCP 的状态机

其实，网络上的传输是没有连接的，包括TCP也是一样的。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。

<div align="center"> <img src="pic/TCP状态机.png"/> </div>
（吐个槽：看到这样复杂的状态机，就知道这个协议有多复杂，复杂的东西总是有很多坑爹的事情，所以TCP协议其实也挺坑爹的）

### 为什么建链接要3次握手，断链接需要4次挥手？

* 对于3次握手：`主要是要初始化Sequence Number 的初始值`。
   + 通信的双方要互相通知对方自己的初始化的Sequence Number 也就上图中的 x 和 y。
   + 这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）
* 对于4次挥手：
   + 其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。





# 4 TCP滑动窗口

我们都知道，TCP必需要解决的可靠传输以及包乱序（reordering）的问题，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。

所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术

## 滑动窗口是如何保证顺序的？

1 首先假定主机B给主机A发送一个确认报文段【`rwnd=20 ack=31`】(表明主机B自己的接收窗口大小为20 期望收到的下一个序号为31(序号为30以及以前的数据收到了))   
主机A在收到确认报文后 就可以构造自己的发送窗口了，发送窗口的样子如图所示
<div align="center"> <img src="pic/滑动窗口01.png"/> </div>

2 现在假设主机A发送了序号【31-41】的数据，此时发送窗口的位置并没有改变,发送窗口内【31-41】的数据 已经发送但是还没收到确认，而序号为【42-50】的数据是允许发送但尚未发送的，考虑一下 我们如何描述发送窗口的状态？ 

<div align="center"> <img src="pic/滑动窗口02.png"/> </div>

3 我们再来看看主机B的接收窗口，假设主机A发送的【32-33】数据到达了主机B 由于他们序号落在了主机窗口内，所以主机B接收他们，将他们存入缓存，但是他们是未按序到达的数据（因为序号为31的数据还没有到达）请注意：**`主机B只能对按序收到的数据中的最高序号给出确认`** 因此主机B 因此主机B给出的确认报文段中的确认序号仍然是31（也就是希望收到序号为31的数据）
<div align="center"> <img src="pic/滑动窗口03.png"/> </div>

4 现在假定主机B收到了31的数据，并把数据交付给应用进程，之后，主机B就可以删除这些数据，并把接收窗口向前移动3个序号，给主机A发送确认报文段【`rwnd=20 ack=34`】
<div align="center"> <img src="pic/滑动窗口04.png"/> </div>

5 现在确认报文段【`rwnd=20 ack=34`】到达了主机A，主机A收到后就可以把发送窗口向前滑动3个序号 窗口尺寸仍为20，这样就有新序号落入滑动窗口中，而序号【31-33】数据就可以从窗口中删除了

<div align="center"> <img src="pic/滑动窗口05.png"/> </div>

6主机A继续发送数据 现在发送窗口内的发送序号已经都用完了（都发出去了）主机A在未收到主机B的确认下，不能在发送新的数据，发送窗口内的数据如果迟迟收不到来自主机B的确认，则会产生**超时重传**
<div align="center"> <img src="pic/滑动窗口06.png"/> </div>

## 什么时候给对端发送确认消息？


延迟ACK：每一次收到对方的包的时候，比如收到了一个37 这时候会开启一个定时器：叫做延迟定时器 超过200ms开始发送确认消息，检测之前的包有没有收到，如果200ms以内再有包进来，这时候会再开一个200ms的定时器


# 5 TCP拥塞控制 （发送方）
拥塞控制主要是四个算法：
* 1）慢启动；
* 2）拥塞避免；
* 3）快重传；
* 4）快恢复。


## 1 慢启动算法 (指数级增长)
慢启动的算法如下(cwnd全称Congestion Window)：

* 1）连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。
* 2）每当收到一个ACK，cwnd++; 呈线性上升
* 3）每当过了一个RTT，cwnd = cwnd*2; 呈指数让升
* 4）还有一个ssthresh（slow start threshold）【门限值or筏值】，是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）
<div align="center"> <img src="pic/拥塞控制01.png"/> </div>



## 2 拥塞避免算法 (线性+1规律增长)
 
前面说过，还有一个ssthresh（slow start threshold）【门限值or筏值】，是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：

* 1）收到一个ACK时，cwnd = cwnd + 1/cwnd
* 2）当每过一个RTT时，cwnd = cwnd + 1

这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。


------------------------------------------------------------------------

慢启动和拥塞避免算法是1988年提出的算法 1990年又增加了两个新的拥塞控制算法，这就是快重传和快恢复


* 有时候，个别报文段会在网络中丢失，但是实际上网络并未发生拥塞
   + 这将导致发送方超时重传，并误认为网络发生拥塞
   + 发送方错误使用慢启动算法，cwnd=1 因而降低了传输效率 


------------------------------------------------------------------------



## 3 快重传和快恢复



* 采用快重传算法可以让发送方今早知道发生了个别报文段的丢失
* 所谓快重传 就是使发送方尽快进行重传，而不是等超时重传计时器超时在重传
  + 要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认
  + 即使收到了失序的报文段也要立即发出对已经收到报文段的重复确认
  + 发送方一旦收到了`3个连续的重复确认`，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时在重传

<div align="center"> <img src="pic/拥塞控制02.png"/> </div>

```c
1 假设我们现在发送6个报文段 接收方正常收到了M1和M2 并发回【确认M1和确认M2】的报文段
2 此时发送方的3号报文段M3 丢失，发送方继续发送M4 M5 M6，接收方收到M4后，发现这不是按序到达的报文段，因此发回【重复确认M2】（主机B只能对按序收到的数据中的最高序号给出确认），收到M5，M6后，发现还不是按序到达的，因此在每次发回【重复确认M2】

3 发送方一旦收到了`3个连续的重复确认`，就将相应的报文段M3立即重传，接收方收到后发回【确认M6】重传成功 AMD yes！！！
```
* 发送方一旦收到了3个重复确认，就知道了只是丢失了个别报文段。于是启动的是快恢复算法
   + 快恢复的实现是把快恢复开始时候拥塞窗口值在增大一些 既：cwnd = sshthresh（门限值）  + 3 * MSS （3的意思是确认有3个数据包被收到了）
      + 既然发送方收到3个重复的确认，就表明有3个报文段已经离开了网络
      + 这3个报文段现在已经停留在接收方的缓存中
      + 可见现在网络上不是堆积了报文段而是减少了3个报文段。因此可以适当调大点
   

## 最后 来张总结图

<div align="center"> <img src="pic/拥塞控制03.png"/> </div>



# 6 TCP流量控制（接收方）
TCP利用滑动窗口机制实现流量控制机制，一般来说，我们希望数据传的总是更快一些。但是如果对方发的太快，接收方有可能来不及接收，这就会造成数据的丢失。也就是说，所谓的流量控制，就是让发送方的发送速率不要太快，让接收方来得及接收  

## TCP流量控制举例
假设主机AB之间已经建立了TCP连接： A给B发送数据，B对A进行流量控制 先不考虑拥塞情况  
假设主机A每次发送的报文段可携带100字节数据在  在建立连接时候 B告诉A ，我的接收窗口awnd=400，因此，主机A给自己发送窗口设置为400

主机A先发送一个报文段（1-100字节） 【seq=1】这时候还能发送300字节   
主机A在发送一个报文段（101-200） 【seq=101】这时候还能发送200字节  
主机A在发送一个报文段（201-300）【seq=201】此时假设报文丢失 ，此时A还能发送100字节  

此时 主机B对A发送的201号以前的进行确认 B将自己窗口调整为300，并通过A【ACK=1 ack=201，rwnd=300】  （**`对A进行流量控制`**） （300是B根据自己的可用缓存调整的）

<div align="center"> <img src="pic/流量控制01.png"/> </div>


主机A收到累积确认后，将滑动窗口向前滑动，将已经确认的序号移出滑动窗口，由于主机B将自己接受窗口调整为300，因此主机A将自己发送窗口调整为300 此时滑动窗口的内容是（200-500字节）， 此时（201-300）的是已经发送但没收到确认的数据，若重传计时器超时，他们会被重传  

主机A继续发送一个报文段（301-400）【seq=301】还能发送100  
主机A继续发送一个报文段（401-500）【seq=401】此时还能发送0字节 此时序号落在滑动窗口里面的数据已经全部发送出去了

<div align="center"> <img src="pic/流量控制02.png"/> </div>


假设现在（201-300）的重传计时器超时了 主机A将他们封装成一个新的报文段重新发送出去【seq=201】但是不能发送新的数据   

主机B收到这个超时重传的数据后，主机B对A发送的501之前数据进行确认，B将自己的接收窗口调整为100，并且通过A 【ACK=1 ack=501，rwnd=100】（**`对A进行流量控制`**）

<div align="center"> <img src="pic/流量控制03.png"/> </div>

主机A收到该累积确认后，将发送窗口向前滑动，将已经确认的序号移出滑动窗口。由于主机B将接收窗口调整为100，因此主机A相应将自己发送窗口调整为100，目前主机A发送窗口的序号为（501-600）  

主机A在发送一个报文（501-600）【seq=501】至此 主机A发送窗口的数据已经全部发送出去了，不能在发送新数据了  

主机B收到TCP报文段后，对601号之前的数据进行累积确认 并将自己接收窗口调整为0 并通告A【ACK=1 ack=601，rwnd=0】（**`对A进行流量控制`**）  

主机A收到该累积确认后，将发送窗口向前滑动，将确认序号的数据移出滑动窗口，由于主机B在接收窗口目前为0，所以主机A的发送窗口也为0，目前，主机A不能在发送报文段了

<div align="center"> <img src="pic/流量控制04.png"/> </div>

假设主机B向A发送了0窗口不久，B的接收缓存又有了一些存储空间，于是B调整自己的接收窗口为300并通告A，等待A发来数据。但是该通告丢失了【rwnd=300】  

此时A也一直等待收到B发送的非0窗口的通知。而B也一直等待A发数据，这样就23333  
```c

为了解决这个问题，TCP为每一个连接设有一个持续计时器，只要有一方收到对方的0窗口通知，就启动持续计时器，若持续计时器超时，就发送一个0窗口探测报文，仅携带一字节的数据，而对方在确认这个报文段时，给出自己现在的窗口值，如果窗口仍然是0，那么收到这个报文段的一方，那么收到这个报文段的一方就重新启动持续计时器，如果窗口不是0，那么死锁的僵局就可以被打破

这样是不是有一个疑问？？ 主机A所发送的0窗口探测报文段到达主机B时，如果主机B此时的接收窗口仍然为0，那么主机B怎么接收这个0窗口探测报文段，那怎么给主机A发送确认呢？？  

实际上  TCP规定 即使接收窗口大小为0，也必须接受0窗口探测报文段，确认报文段，以及携带有紧急数据的报文段

```


<div align="center"> <img src="pic/流量控制05.png"/> </div>

需要指出的是： 发送窗口是在拥塞窗口和接收窗口中取最小者

# TCP协议中的疑难杂症

## 疑症 1 ：TCP 的三次握手、四次挥手

TCP协议状态机：  
* 要弄清TCP建立连接需要几次交互才行，我们需要弄清建立连接进行初始化的目标是什么。TCP进行握手初始化一个连接的目标是：分配资源、初始化序列号(通知peer对端我的初始序列号是多少)，知道初始化连接的目标，那么要达成这个目标的过程就简单了


握手过程可以简化为下面的四次交互：

* 1 ) clien 端首先发送一个 SYN 包告诉 Server 端我的初始序列号是 X；
* 2 ) Server 端收到 SYN 包后回复给 client 一个 ACK 确认包，告诉 client 说我收到了；
* 3 ) 接着 Server 端也需要告诉 client 端自己的初始序列号，于是 Server 也发送一个 SYN 包告诉 client 我的初始序列号是Y；
* 4 ) Client 收到后，回复 Server 一个 ACK 确认包说我知道了。


在三次握手过程中，细心的同学可能会有以下疑问：

* 1）初始化序列号X、Y是可以是写死固定的吗，为什么不能呢？
* 2）假如Client发送一个SYN包给Server后就挂了或是不管了，这个时候这个连接处于什么状态呢？会超时吗？为什么呢？

TCP进行断开连接的目标是：回收资源、终止数据传输。由于TCP是全双工的，需要Peer两端分别各自拆除自己通向Peer对端的方向的通信信道。

这样需要四次挥手来分别拆除通信信道，就比较清晰明了了：

* 1）Client 发送一个FIN包来告诉 Server 我已经没数据需要发给 Server了；
* 2）Server 收到后回复一个 ACK 确认包说我知道了；
* 3）然后 server 在自己也没数据发送给client后，Server 也发送一个 FIN 包给 Client 告诉 Client 我也已经没数据发给client 了；
* 4）Client 收到后，就会回复一个 ACK 确认包说我知道了。

在四次挥手的过程中，细心的同学可能会有以下疑问：

* 1）Client和Server同时发起断开连接的FIN包会怎么样呢，TCP状态是怎么转移的?
* 2）左侧图中的四次挥手过程中，Server端的ACK确认包能不能和接下来的FIN包合并成一个包呢，这样四次挥手就变成三次挥手了。
* 3）四次挥手过程中，首先断开连接的一端，在回复最后一个ACK后，为什么要进行TIME_WAIT呢(超时设置是 2*MSL，RFC793定义了MSL为2分钟，Linux设置成了30s)，在TIME_WAIT的时候又不能释放资源，白白让资源占用那么长时间，能不能省了TIME_WAIT呢，为什么


## 疑症 2 : TCP 连接的初始化序列号能否固定

如果初始化序列号（缩写为ISN：Inital Sequence Number）可以固定，我们来看看会出现什么问题：

* 假设ISN固定是1，Client和Server建立好一条TCP连接后，Client连续给Server发了10个包，这10个包不知怎么被链路上的路由器缓存了(路由器会毫无先兆地缓存或者丢弃任何的数据包)，这个时候碰巧Client挂掉了；
* 然后Client用同样的端口号重新连上Server，Client又连续给Server发了几个包，假设这个时候Client的序列号变成了5；
* 接着，之前被路由器缓存的10个数据包全部被路由到Server端了，Server给Client回复确认号10，这个时候，Client整个都不好了，这是什么情况？我的序列号才到5，你怎么给我的确认号是10了，整个都乱了。

递增方式的ISN，很容易让攻击者猜测到TCP连接的ISN，现在的实现大多是在一个基准值的基础上进行随机的。


## 疑症 3 : 初始化连接的 SYN 超时问题

目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了.所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会把断开这个连接。  

由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称 SYN flood 攻击)

## 疑症 4 : TCP 的 Peer 两端同时断开连接

两端Peer可能出现完全一样的状态转移 FIN_WAIT1-->CLOSEING-->TIME_WAIT，也就会Client和Server最后同时进入TIME_WAIT状态。

## 疑症 5 : 四次挥手能不能变成三次挥手呢？

答案是可能的。

如果Server在收到Client的FIN包后，在也没数据需要发送给Client了，那么对Client的ACK包和Server自己的FIN包就可以合并成为一个包发送过去，这样四次挥手就可以变成三次了(似乎linux协议栈就是这样实现的)。

## 疑症 6 : TCP 的头号疼症 TIME_WAIT 状态

### 哪一端会进入TIME_WAIT呢？为什么?

TCP主动关闭连接的那一方会最后进入TIME_WAIT。

那么怎么界定主动关闭方呢？是否主动关闭是由FIN包的先后决定的，就是在自己没收到对端Peer的FIN包之前自己发出了FIN包，那么自己就是主动关闭连接的那一方。

我们来看看TCP四次挥手可以简单分为下面三个过程：

* 过程一：主动关闭方发送FIN；
* 过程二：被动关闭方收到主动关闭方的FIN后发送该FIN的ACK，被动关闭方发送FIN；
* 过程三：主动关闭方收到被动关闭方的FIN后发送该FIN的ACK，被动关闭方等待自己FIN的ACK。

问题就在过程三中，据TCP协议规范，不对ACK进行ACK，如果主动关闭方不进入TIME_WAIT，那么主动关闭方在发送完ACK就走了的话，如果最后发送的ACK在路由过程中丢掉了，最后没能到被动关闭方，这个时候被动关闭方没收到自己FIN的ACK就不能关闭连接，接着被动关闭方会超时重发FIN包，但是这个时候已经没有对端会给该FIN回ACK，被动关闭方就无法正常关闭连接了，所以主动关闭方需要进入TIME_WAIT以便能够重发丢掉的被动关闭方FIN的ACK。

### TIME_WAIT状态是用来解决或避免什么问题呢？

* 如果主动关闭方不进入TIME_WAIT，那么在主动关闭方对被动关闭方FIN包的ACK丢失了的时候，被动关闭方由于没收到自己FIN的ACK，会进行重传FIN包，这个FIN包到主动关闭方后，由于这个连接已经不存在于主动关闭方了，这个时候主动关闭方无法识别这个FIN包，协议栈会认为对方疯了，都还没建立连接你给我来个FIN包？，于是回复一个RST包给被动关闭方
* 防止已经断开的连接1中在链路中残留的FIN包终止掉新的连接2
* 防止链路上已经关闭的连接的残余数据包(a lost duplicate packet or a wandering duplicate packet) 干扰正常的数据包，造成数据流的不正常
   
### 实践中总结的解决方法

* 1）推荐方法，只能治标不治本:重用本地端口设置SO_REUSEADDR和SO_REUSEPOR
* 2）修改内核TIME_WAIT等待的值：
* *）不推崇，但目前我们是这样做的： 利用RST包从外部清掉TIME_WAIT链接： 这种关闭方式称为“强行关闭


## 疑症7：TCP的延迟确认机制
确认号(ACK)本身就是不含数据的分段，因此大量的确认号消耗了大量的带宽，虽然大多数情况下，ACK还是可以和数据一起捎带传输的，但是如果没有捎带传输，那么就只能单独回来一个ACK，如果这样的分段太多，网络的利用率就会下降  

为缓解这个问题，RFC建议了一种延迟的ACK 延迟一段时间的目的是看能不能和接收方要发给发送方的数据一起回去，因为TCP协议头中总是包含确认号的，如果能的话，就将数据一起捎带回去，这样网络利用率就提高了  

延迟ACK就算没有数据捎带，那么如果收到了按序的两个包，那么只要对第二包做确认即可，这样也能省去一个ACK消耗 RFC建议最多等待2个包的积累确认，这样能够及时通知对端Peer，我这边的接收情况

Linux实现中，有延迟ACK和快速ACK，并根据当前的包的收发情况来在这两种ACK中切换。一般情况下，ACK并不会对网络性能有太大的影响，延迟ACK能减少发送的分段从而节省了带宽，而快速ACK能及时通知发送方丢包，避免滑动窗口停等，提升吞吐率。  

关于ACK分段，有个细节需要说明一下，ACK的确认号，是确认按序收到的最后一个字节序，对于乱序到来的TCP分段，接收端会回复相同的ACK分段，只确认按序到达的最后一个TCP分段。TCP连接的延迟确认时间一般初始化为最小值40ms，随后根据连接的重传超时时间（RTO）、上次收到数据包与本次接收数据包的时间间隔等参数进行不断调整。



## 疑症8：TCP的重传机制以及重传的超时计算

为了使我们的重传机制更高效，如果我们能够比较准确知道在当前网络状况下，一个数据包从发出去到回来的时间RTT——Round Trip Time，那么根据这个RTT我们就可以方便设置TimeOut——RTO（Retransmission TimeOut）了。   

TCP的重传是由超时触发的，这会引发一个重传选择问题，假设TCP发送端连续发了1、2、3、4、5、6、7、8、9、10共10包，其中4、6、8这3个包全丢失了，由于TCP的ACK是确认最后连续收到序号  

这样发送端只能收到3号包的ACK，这样在TIME_OUT的时候，发送端就面临下面两个重传选择：  
* 1）仅重传4号包；
* 2）重传3号后面所有的包，也就是重传4~10号包。

快速重传： 连续收到3个相同的ACK，那么说明当前的网络状况变好了，可以重传丢失的包了  

快速重传解决了timeout的问题，但是没解决重传一个还是重传多个的问题。出现难以决定是否重传多个包问题的根源在于，发送端不知道那些非连续序号的包已经到达接收端了，但是接收端是知道的，如果接收端告诉一下发送端不就可以解决这个问题吗？  

于是，RFC2018提出了Selective Acknowledgment (SACK，选择确认)机制

SACK依靠接收端的接收情况反馈，解决了重传风暴问题，这样够了吗？接收端能不能反馈更多的信息呢？显然是可以的，  
于是，RFC2883对对SACK进行了扩展，提出了D-SACK，也就是利用第一块SACK数据中描述重复接收的不连续数据块的序列号参数，其他SACK数据则描述其他正常接收到的不连续数据。  
这样发送方利用第一块SACK，可以发现数据段被网络复制、错误重传、ACK丢失引起的重传、重传超时等异常的网络状况，使得发送端能更好调整自己的重传策略。   


# TCP的异常关闭

## 服务器端只Recv消息而不Send消息

1）客户端程序正常运行的情况下，拔掉网线，杀掉客户端程序  
* 目的：模拟客户端死机、系统突然重启、网线松动或网络不通等情况。
* 结论：这种情况下服务器程序没有检测到任何异常，并最后等待“超时”才断开TCP连接  

2）客户端程序发送很多数据包后正常关闭Socket并exit进程(或不退出进程)：
* 目的：模拟客户端发送完消息后正常退出的情况。
* 结论：这种情况下服务器程序能够成功接收完所有消息，并最后收到“对端关闭”（Recv返回零）消息。

3）客户端程序发送很多数据包后不关闭Socket直接exit进程  
* 目的：模拟客户端程序退出而忘记关闭Socket的情况（比如通过Windows窗口的关闭图标退出进程，而没有捕获相应关闭事件做正常退出处理等）。
* 结论：这种情况下服务器程序能够收到部分TCP消息，然后收到“104: Connection reset by peer”（Linux下）或“10054: An existing connection was forcibly closed by the remote host”（Windows下）错误。  

4）客户端程序发送很多数据包的过程中直接Kill进程：  
* 目的：模拟客户端程序崩溃或非正常方式结束进程（比如Linux下"kill -9"或Windows的任务管理器杀死进程）的情况。
* 结论：这种情况下服务器程序很快收到“104: Connection reset by peer”（Linux下）或“10054: An existing connection was forcibly closed by the remote host”（Windows下）错误

## 服务器端Recv消息并Send应答消息

1）客户端程序发送很多数据包后正常关闭Socket并exit进程（或不退出进程）：
* 目的：模拟客户端正常关闭Socket后，服务器端在检查到TCP对端关闭前向客户端发送消息的情况。  
* 结论：这种情况下服务器程序接收和发送部分TCP消息后，在Send消息时产生“32: Broken pipe”（Linux下）或“10053: An established connection was aborted by the software in your host machine”（Windows下）错误。

2）客户端程序发送很多数据包后不关闭Socket直接exit或Kill进程：
*  目的：模拟客户端程序退出而忘记关闭Socket、或客户端程序崩溃或非正常方式结束进程的情况。
*  结论：这种情况下服务器程序在Recv或Send消息时产生“104: Connection reset by peer”（Linux下）或“10054: An existing connection was forcibly closed by the remote host”（Windows下）错误。

## 总结 

1）当TCP连接的进程在忘记关闭Socket而退出、程序崩溃、或非正常方式结束进程的情况下：
* （Windows客户端），会导致TCP连接的对端进程产生“104: Connection reset by peer”（Linux下）或“10054: An existing connection was forcibly closed by the remote host”（Windows下）错误。
2）当TCP连接的进程机器发生死机、系统突然重启、网线松动或网络不通等情况下：
* （Windows客户端），连接的对端进程可能检测不到任何异常，并最后等待“超时”才断开TCP连接。

3）当TCP连接的进程正常关闭Socket时，对端进程在检查到TCP关闭事件之前仍然向TCP发送消息：
* （Windows客户端），则在Send消息时会产生“32: Broken pipe”（Linux下）或“10053: An established connection was aborted by the software in your host machine”（Windows下）错误。


## TCP异常进一步测试研究  

1）服务器端已经close了Socket，客户端再发送数据：  
* 目的：测试在TCP对端进程已经关闭Socket时，本端进程还未检测到连接关闭的情况下继续向对端发送消息。
* 结论：第一包可以发送成功，但第二包发送失败，错误码为“10053: An established connection was aborted by the software in your host machine”（Windows下）或“32: Broken pipe，同时收到SIGPIPE信号”（Linux下）错误。  

2）服务器端发送数据到TCP后close了Socket，客户端再发送一包数据，然后接收消息：
* 目的：测试在TCP对端进程发送数据后关闭Socket，本端进程还未检测到连接关闭的情况下发送一包消息，接着接收消息。
* 结论：客户端能够成功发送第一包数据（这会导致服务器端发送一个RST包 <已抓包验证>），客户端再去Recv时，对于Windows和Linux程序有如下不同的表现：
        - 2.1）Windows客户端程序：Recv失败，错误码为“10053: An established connection was aborted by the software in your host machine”；
        - 2.2）Linux客户端程序：能正常接收完所有消息包，最后收到正常的对端关闭消息（这一点与Window下不一样，RST包没有被提前接收到  

3）服务器端在TCP的接收缓冲区中还有未接收数据的情况下close了Socket，客户端再收包：  
* 目的：测试在TCP的接收缓冲区中还有未接收数据的情况下关闭Socket时，对端进程是否正常。
* 结论：这种情况服务器端就会向对端发送RST包，而不是正常的FIN包（已经抓包证明），这就会导致客户端提前（RST包比正常数据包先被收到）收到“10054: An existing connection was forcibly closed by the remote host”（Windows下）或“104: Connection reset by peer”（Linux下）错误。


  








