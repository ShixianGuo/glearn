---
layout: post
title: '服务器模型Reactor与Proactor'
subtitle: ''
date: 2019-09-19
categories: 技术
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-postcover.jpg'
tags: 网络编程 
---

## 前言
网络连接上的消息处理，可以分为两个阶段：**等待消息准备好、消息处理**。  

当使用默认的阻塞套接字时（一连接一线程），往往是把 这两个阶段合而为一这样操作套接字的代码所在的线程就得睡眠来等待消息准备好，这导致了线程会频繁的睡眠、唤醒，从而影响了 CPU 的使用效率。   

高并发编程方法当然就是把两个阶段分开处理。当然，这也要求套接字必须是非阻塞的，
   

作为一个高性能服务器程序通常需要考虑处理三类事件： **I/O 事件，定时事件及信号**

等待消息准备好：**就是IO多路复用了** 2333
两种高效的事件处理模型：**Reactor 和 Proactor。** 

**问题**
>* epoll是用来管理网络IO的 怎么管理大量的fd？

## Reactor 模型 
我们先看下普通函数的调用机制：
>程序调用某函数，函数执行，程序等待，函数将结果和控制权返回给程序，程序继续处理  

Reactor与普通函数调用机制的区别在于：
>应用程序不是主动的调用某个 API 完成处理，而是恰恰 相反，Reactor 逆置了事件处理流程，应用程序需要提供相应的接口并注册到 Reactor 上， 如果相应的时间发生，Reactor 将主动调用应用程序注册的接口，这些接口又称为“回调函数”。 

Reactor 模型有三个重要的组件： 
>* 多路复用器： epoll_wait
>* 事件分发器： if(fd&EPOLLIN)   if(fd&EPOLLOUT) 
>* 事件处理器： read_cb()        write_cb()  

具体流程如下
>1. 注册读就绪事件和相应的事件处理器  
>2. 事件分离器等待事件； 
>3. 事件到来，激活分离器，分离器调用事件对应的处理器； 
>4. 事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制 权

Reactor优点： 
> 响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的  
> 编程相对简单
> 可扩展性，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源  
> 可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性； 

Reactor 模型开发效率上比起直接使用IO复用要高，它通常是单线程的，设计目标是希望单线程使用一颗CPU的全部资源，但也有附带优点，即每个事件处理中很多时候可以 不考虑共享资源的互斥访问  

但是缺点也是明显的  多核场景下就有点弱鸡和悲剧了。但是并不是所有的多核场景都这样 主要还是看业务的相关性 例如 如果程序业务很简单，例如只是简单的访问一些提供了并发访问的服务，就可以直接开 启多个反应堆，每个反应堆对应一颗 CPU 核心，这些反应堆上跑的请求互不相关，这是完全可以利用多核的

给出[Reactor模型代码实现]()

## Proactor 模型 







